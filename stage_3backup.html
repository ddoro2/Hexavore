
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Your Page Title</title>
    <link rel="stylesheet" href="styles.css"> 
</head>
<body>

    <header>
        <h1>Hexavore - III</h1>
    </header>
    <div class="main" id="grid-container">
       
</body>
<script>
    // Color states from light to deep blue
    const colorStates = ["#cceeff", "#99ccff", "#3399ff", "#0066cc"];
    let hexMap = {};
    
    document.addEventListener("DOMContentLoaded", function () {
        function createHexGrid() {
            const mainContainer = document.getElementById('grid-container');
            const hexagonCounts = [6, 7, 8, 9, 10, 11, 10, 9, 8, 7, 6]; // Hexagons per row
            
            // Create hexagons and distribute them across rows
            for (let i = 0; i < 6; i++) {
                const rowContainer = document.createElement('div');
                rowContainer.className = 'container';

                for (let j = 0; j < hexagonCounts[i]; j++) {
                    const hexagon = document.createElement('div');
                    hexagon.className = 'hexagon';
                    
                    hexagon.dataset.q = `${5 + j -i}`;  // Set the Q value
                    hexagon.dataset.r = `${i}`;  // Set the R value
                    const hexInner = document.createElement('div');
                    hexInner.className = 'hexagon-inner';

                    
                    if (j === 0 && i === 0) {  // Outer hexagon (0th element, index 0)
                        const goalTriangle = document.createElement('div');
                        goalTriangle.className = 'triangle-goal';
                        hexInner.appendChild(goalTriangle);
                    }
                    
                    hexagon.appendChild(hexInner);
                    rowContainer.appendChild(hexagon);


                    hexMap[`${5+j-i},${i}`] = { element: hexagon, state: 0 };
                    console.log(`Create Hexagon From: Q = ${5+j-i}, R = ${i}`);
                }

                mainContainer.appendChild(rowContainer);
            }

            for (let i = 6; i < 11; i++) {
                const rowContainer = document.createElement('div');
                rowContainer.className = 'container';

                for (let j = 0; j < hexagonCounts[i]; j++) {
                    const hexagon = document.createElement('div');
                    hexagon.className = 'hexagon';
                    hexagon.dataset.q = `${0+j}`;  // Set the Q value
                    hexagon.dataset.r = `${i}`;  // Set the R value
                    const hexInner = document.createElement('div');
                    hexInner.className = 'hexagon-inner';

                    if (j === 5 && i === 10) {  // Middle hexagon (6th element, index 5)
                        const startTriangle = document.createElement('div');
                        startTriangle.className = 'triangle-start';
                        hexInner.appendChild(startTriangle);
                        hexInner.style.backgroundColor = "#cceeff";
                    }
                    
                    hexagon.appendChild(hexInner);
                    rowContainer.appendChild(hexagon);


                    hexMap[`${0+j},${i}`] = { element: hexagon, state: 0 };
                    console.log(`Create Hexagon From: Q = ${0+j}, R = ${i}`);
                }

                mainContainer.appendChild(rowContainer);
            }
            console.log(hexMap);
            
        }


        function setWalls(wallCoordinates) {
    wallCoordinates.forEach(([q, r]) => {
        const wallKey = `${q},${r}`;
        
        // Check if the hexagon exists in the grid
        if (hexMap[wallKey]) {
            const wallHex = hexMap[wallKey].element;
            const wallHexInner = wallHex.querySelector('.hexagon-inner');
            
            if (q === 5 && r === 5) {
                let red = 255; // Start with very light red
                let green = 200;
                let blue = 200;
                const steps = 17;
                const intervalTime = 1000; // 1 second intervals

                // Function to start the color transition
                function startColorTransition() {
                    let stepCount = 0;

                    // Set initial color
                    wallHexInner.style.backgroundColor = `rgb(${red}, ${green}, ${blue})`;

                    const colorInterval = setInterval(() => {
                        if (stepCount < steps) {
                            // Gradually reduce green and blue to intensify red
                            green -= 8;
                            blue -= 8;
                            wallHexInner.style.backgroundColor = `rgb(${red}, ${green}, ${blue})`;
                            stepCount++;
                        } else {
                            clearInterval(colorInterval); // Stop the interval after 18 steps

                            // After the transition completes, reset the color back to the original light red
                            setTimeout(() => {
                                wallHexInner.style.backgroundColor = `rgb(255, 200, 200)`; // Reset to very light red
                                red = 255;
                                green = 200;
                                blue = 200;
                                // Start the color transition again after a short delay
                                setTimeout(startColorTransition, 500); // Repeat after 500ms
                            }, 500); // Reset after a short delay (to allow the final color to be visible)
                        }
                    }, intervalTime);
                }

                // Start the color transition
                startColorTransition();
            } else {
                wallHexInner.style.backgroundColor = "lightgray"; // Wall color for other coordinates
            }
            
            // Disable interaction
            wallHex.style.pointerEvents = "none";
            hexMap[wallKey].state = -1;
        }
    });
}



// Example wall coordinates (same as before)
const wallCoordinates = [
    [6, 0], [7, 0], [4, 1], [3, 2], [8, 1],
    [6, 2], [7, 2], [4, 3], [5, 3], [2, 4],
    [3, 4], [10, 2], [8, 3], [9, 3],
    [7, 4], [2, 6], [3, 6], [0, 7],
    [1, 7], [6, 8], [7, 8], [4, 9], [3, 10],
    [1, 9], [2, 8], [3, 8], [4, 7], [5, 7],
    [6, 6], [7, 6], [8, 5], [9, 5], [5, 5]  // Target wall at [5,5]
];




        createHexGrid();
        setWalls(wallCoordinates); 
        const hexagons = document.querySelectorAll(".hexagon");

hexagons.forEach(hex => {
    hex.addEventListener("click", function () {
        const hexInner = hex.querySelector('.hexagon-inner');
        const currentColor = window.getComputedStyle(hexInner).backgroundColor;

        // Convert the computed color (rgb) to hex to check if it matches the states
        const rgbToHex = (rgb) => {
            const rgbArray = rgb.match(/\d+/g);
            const hex = rgbArray
                ? `#${((1 << 24) | (parseInt(rgbArray[0]) << 16) | (parseInt(rgbArray[1]) << 8) | parseInt(rgbArray[2])).toString(16).slice(1)}`
                : null;
            return hex;
        };

        const currentHexColor = rgbToHex(currentColor);

        // Check if the hexagon color is in the colorStates array (except white)
        if (colorStates.includes(currentHexColor) && currentHexColor !== "#ffffff") {
            let q = hex.dataset.q;
            let r = hex.dataset.r;

            // Get the current state of the hexagon
            let currentState = hexMap[`${q},${r}`].state;

            // If the hexagon is the boldest blue (last state)
            if (currentState === colorStates.length) {
                // Spread the color to neighbors
                spreadLightBlueToNeighbors(q, r);
                hexInner.style.backgroundColor = colorStates[0]; // Revert to original state (lightest blue)
                hexMap[`${q},${r}`].state = 0; // Reset the state to 0 (first state)
            } else {
                // Otherwise, change the color to the next state
                if (currentState < colorStates.length) {
                    hexInner.style.backgroundColor = colorStates[currentState];

                    // Move to the next state
                    hexMap[`${q},${r}`].state = currentState + 1;
                }
            }

            // Check if the goal hexagon is clicked and in the final state
            if (hex.querySelector('.triangle-goal') && currentState === colorStates.length - 1) {
                window.location.href = "stage_4.html"; // Redirect to the next stage
            }
        }
    });
});


function createShockwave(q, r) {
    const hexKey = `${q},${r}`;
    const targetHex = hexMap[hexKey].element;

    // Create shockwave element
    const shockwave = document.createElement('div');
    shockwave.className = 'shockwave';

    // Position the shockwave over the target hexagon
    const hexRect = targetHex.getBoundingClientRect();
    const containerRect = document.getElementById('grid-container').getBoundingClientRect();

    const offsetX = hexRect.left - containerRect.left - hexRect.height / 12;
    const offsetY = hexRect.top - containerRect.top + hexRect.height * 3;

    // Apply position
    shockwave.style.left = `${offsetX}px`;
    shockwave.style.top = `${offsetY}px`;

    // Append the shockwave to the main container
    const mainContainer = document.getElementById('grid-container');
    mainContainer.appendChild(shockwave);

    // Remove the shockwave after the animation completes
    setTimeout(() => {
        console.log("Shockwave animation completed and removing element.");
        mainContainer.removeChild(shockwave); // Explicitly remove the shockwave from the container
    }, 1900);
    
}





/*
function startDecreasingColors() {
    // Run every 10 seconds (10000 ms)
    setInterval(() => {
        Object.keys(hexMap).forEach(key => {
            const hexagon = hexMap[key].element;
            const hexInner = hexagon.querySelector('.hexagon-inner');
            let currentState = hexMap[key].state;

            // If the hexagon is not in the first state (lightest color)
            if (currentState > 0) {
                hexMap[key].state = currentState - 1; // Decrease state by 1
                hexInner.style.backgroundColor = colorStates[currentState - 1]; // Update the color
            }
            if (colorStates[currentState - 1] === 'lightblue') {
                    hexInner.style.backgroundColor = 'white'; // Change light blue to white
            }
        });

        // Call shockwave on specific hex (e.g., 5, 5) after the color update
        createShockwave(5, 5);
    }, 10000); // 10000 ms = 10 seconds
}
startDecreasingColors();
*/

function startDecreasingColors() {
    // Run every 10 seconds (10000 ms)
    setInterval(() => {
        createShockwave(5, 5);
        // First reduction step: immediately reduce the state of all hexagons
        Object.keys(hexMap).forEach(key => {
            const hexagon = hexMap[key].element;
            const hexInner = hexagon.querySelector('.hexagon-inner');
            let currentState = hexMap[key].state;

            // If the hexagon is not in the first state (lightest color)
            const currentColor = window.getComputedStyle(hexInner).backgroundColor;
        
        // Check if the color is light blue (e.g., "rgb(173, 216, 230)" for light blue)
        if (currentColor === "rgb(204, 238, 255)") {
            hexInner.style.backgroundColor = "white";  // Change color to white
            hexMap[key].state = 0;                     // Reset state to 0
        } else if (currentState > 0) {
            // Reduce the state for other hexagons
            hexMap[key].state = currentState - 1;
            hexInner.style.backgroundColor = colorStates[currentState - 1]; // Update the color
        }
   
        });

        // Wait for 10 seconds before the second reduction
        setTimeout(() => {
            // Second reduction step: after 10 seconds, reduce the state again
            Object.keys(hexMap).forEach(key => {
                const hexagon = hexMap[key].element;
                const hexInner = hexagon.querySelector('.hexagon-inner');
                let currentState = hexMap[key].state;

                // If the hexagon is not in the first state (lightest color)
                const currentColor = window.getComputedStyle(hexInner).backgroundColor;
        
        // Check if the color is light blue (e.g., "rgb(173, 216, 230)" for light blue)
        if (currentColor === "rgb(204, 238, 255)") {
            hexInner.style.backgroundColor = "white";  // Change color to white
            hexMap[key].state = 0;                     // Reset state to 0
        } else if (currentState > 0) {
            // Reduce the state for other hexagons
            hexMap[key].state = currentState - 1;
            hexInner.style.backgroundColor = colorStates[currentState - 1]; // Update the color
        }
                
            });

            // Call shockwave after the second reduction
            createShockwave(5, 5);
        }, 19000); // Wait for 10 seconds before applying the second reduction
    }, 19000); // 10000 ms = 10 seconds for the first reduction
}

startDecreasingColors();




// Function to spread the light blue color to neighbors
function spreadLightBlueToNeighbors(q, r) {
    const neighbors = [
    [parseInt(q) + 0, parseInt(r) + 1],  // Right
    [parseInt(q) + 1, parseInt(r)],      // Bottom-right
    [parseInt(q) + 1, parseInt(r) - 1],  // Bottom-left
    [parseInt(q) + 0, parseInt(r) - 1],  // Left
    [parseInt(q) - 1, parseInt(r)],      // Top-left
    [parseInt(q) - 1, parseInt(r) + 1],  // Top-right
    ];
    console.log(`Checking current = ${q}, R = ${r}`);
    neighbors.forEach(([neighborQ, neighborR]) => {
        console.log(`Checking neighbor at: Q = ${neighborQ}, R = ${neighborR}`);
        // Check if the neighbor is within bounds
        if (hexMap[`${neighborQ},${neighborR}`]) {
            const neighborHex = hexMap[`${neighborQ},${neighborR}`].element;
            const neighborHexInner = neighborHex.querySelector('.hexagon-inner');
            const neighborState = hexMap[`${neighborQ},${neighborR}`].state;
            
            // Only spread light blue to neighbors that are not yet colored
            if (neighborState === 0) {
                neighborHexInner.style.backgroundColor = "#cceeff"; // Light blue
                hexMap[`${neighborQ},${neighborR}`].state = 1; // Mark as occupied
            }
        }
    });
}

// Define the list of coordinates where you want the light blue hexagon to grow
const listGrow = [
    [5, 10]// Add your desired coordinates here
];

function growLightBlue() {
    // Filter hexagons to only those in the listGrow array and that are unoccupied
    const unoccupiedHexagons = Object.keys(hexMap).filter(key => {
        const [q, r] = key.split(',').map(Number); // Get coordinates from the key
        return hexMap[key].state === 0 && listGrow.some(([listQ, listR]) => listQ === q && listR === r);
    });
    
    if (unoccupiedHexagons.length > 0) {
        const randomHexagonKey = unoccupiedHexagons[Math.floor(Math.random() * unoccupiedHexagons.length)];
        const hexagon = hexMap[randomHexagonKey].element;
        hexagon.querySelector('.hexagon-inner').style.backgroundColor = "#cceeff"; // Light blue color
    
        // Mark this hexagon as occupied
        hexMap[randomHexagonKey].state = 1;
    }
}

// Set the interval to make the hexagon grow every 20 seconds
setInterval(growLightBlue, 20000);
    
        
    });


    let startTime = Date.now();
    localStorage.setItem('gameStartTime', startTime);
    console.log(startTime);
    </script>
    

</html>
